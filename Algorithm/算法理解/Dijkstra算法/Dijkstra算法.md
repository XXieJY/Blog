## 1、Dijkstra算法简介
&emsp;&emsp;Dijkstra算法的作者是一个荷兰人Edsger Wybe Dijkstra (Dutch: [ˈɛtsxər ˈʋibə ˈdɛikstra]，这个是从[他的维基百科](https://en.wikipedia.org/wiki/Edsger_W._Dijkstra)上面取得的名字音标，	其实Dijkstra的发音和中文译音“迪杰斯特拉”并不一样。Dijkstra算法是一个求**单源图**最短路的算法，也就是求有权图中一个点（源）到其他点的最短路径。具体来说，算法的输入是：
> * 有权（有向）图
> * 起点（源）
> * 所有边的权非负

&emsp;&emsp;算法的输出是：
> * 起点（源）到其他各点的最短路径

&emsp;&emsp;这里对于算法的输入需要做一个说明：很多资料在介绍Dijkstra算法的时候都说是求**有向图**单源最短路问题，包括《算法导论》上面也这么说，但是Dijkstra算法同样适用于无向图，因为无向图其实可以看做是特殊的有向图，无向图中的`A —— B`等价于有向图中的`A ——> B`且`A <—— B`。此外，图的连通性也不会影响Dijkstra算法的使用，无边就等于边权无穷大，那么最短路径也是无穷大。

## 2、Dijkstra算法思路
&emsp;&emsp;为了后续表述方便，我们令所有结点的集合为`V`，并且下文中的“最短路径”指的是源点`s`到该结点的最短路径。
&emsp;&emsp;Dijkstra算法采用贪心策略，它维护一个集合`S`，该集合包含的是目前已经确定了最短路径的结点。集合`S`最初为空，然后重复从集合`V - S`中选择最短路径估计值（为什么是估计值，后面再解释）最小的结点`u`加入集合`S`，直到没有需要加入集合`S`的点。在加入结点`u`之后，需要对从结点`u`出发的所有边进行**松弛操作**，具体来说，如果存在结点`v`，满足`u ——> v`，且`v`不在集合`S`中，且存在一条从`s`通过`u`到达`v`的路径会比`v`当前最短路径估计值更小，则更新这个估计值。
&emsp;&emsp;《算法导论》一书24.3介绍Dijkstra算法的部分给出了一个执行过程示意图，感觉挺好的，为了便于理解，下面给出这个图（重新画了，有所改动）。
![](./Dijkstra算法-执行过程.png)
&emsp;&emsp;下面简要对上图做一个说明。
&emsp;&emsp;图中，圆圈表示结点，圆圈中的数字表示该结点的最短路径（`INF`表示无穷大），黄色的圆圈表示将要加入集合`S`中的结点，蓝色圆圈表示已经加入集合`S`中的结点。黑色细边上的数字表示权重，绿色粗边表示要进行松弛操作的边，紫色粗边已经确定的最短路径经过的边，黄色粗边表示当前最短路径估计值下经过的边。
&emsp;&emsp;其实理解了上图的过程，也就理解了Dijkstra算法的执行过程。下面给出算法步骤，并以上图为例讲解。为了便于表述，下面内容中“结点的值”指的是结点的最短路径估计值。
> * **结点编号与距离初始化：**我们一般使用数组（`dis[]`）来存储最短路径，所以结点编号一般为`1`至`n`或者`0`至`n-1`。`dis[i]`表示结点`i`的最短路径估计值，初始化`dis[s] = 0; dis[i] = INF(i != s)`。如上图(a)所示，初始化情况下，原点`s`的值为`0`，其它为`INF`。
> * **寻找最近结点加入集合`S`：**对于`V-S`中的结点，寻找一个结点`u`满足`dis[u]`最小，将`u`加入集合`S`。对于上图(a)，此时的集合`S`是空的，第一个要加入的肯定是源点`s`（源点到自己的距离为`0`，最小）；图(b)将源点`s`加入了集合`S`。
> * **对加入集合`S`的点发出的边进行松弛操作：**结点`u`加入集合`S`之后，以结点`u`作为跳板，如果`V-S`中结点的值可以进一步减小，则更新这个估计值。松弛公式为：**`dis[i] = min(dis[i], dis[u]+map[u][i])`**，其中`map[u][i]`表示结点`u`到结点`i`的距离（边权）。如上图(b)所示，将结点`s`加入集合`S`之后，需要对`s`发出且不在`S`中的边进行松弛操作，也就是那两条绿色粗边，然后更新对应的结点`t`和`y`的值，原来都是`INF`，现在更新为更小的值。
> * **重复步骤`2`和`3`：**上图(b)进行了松弛操作之后，结点`y`的值最小，所以接下来要将`y`加入集合`S`。如图(c)所示，将结点`y`加入之后，其最短路径确定了，就是那条紫色粗线，然后要进行松弛操作（三条绿色粗边）更新对应结点值，可以看见结点`t`的值由`10`变成了`8`，这是因为以`y`作为跳板之后，路径变近了，原来是`s ——> t`，现在是`s ——> y ——> t`。其它结点同理。这样以后，结点`z`的值成为最小，要加入集合`S`。如图(d)所示，加入结点`z`之后，进行松弛操作（图中绿色粗边），结点`x`的值变小为`13`。图(e)、(f)就是重复上述的步骤，很好理解。最后就找到了所有结点的最短路径，如图(f)。

&emsp;&emsp;时间复杂度方面，要将所有结点都加入集合`S`，共`n`次循环，每次循环都要扫描一遍查找最近结点，需要`O(n)`，所以一共需要`O(n*n)`的时间。
&emsp;&emsp;好，回应上文，这里解释一下为什么说是**最短路径估计值。**这个词是我拼出来的，或者说是翻译的，《算法导论》在概括Dijkstra算法思路的时候有这样一句话：`The algorithm repeatedly selects the vertex u ∈ V — S with the minimum shortest-path estimate, adds u to S, and relaxes all edges leaving u.`我将这句话中**`shortest-path estimate`**翻译为*最短路径估计值*，不一定准确，但这不是重点，重点在于为什么不直接说`shortest-path`，而要在其后面加一个`estimate`呢？从上图可以发现，在算法执行过程中，进行松弛操作之后很多结点的值可能会变小，直到其加入了集合`S`，这样它的值就确定下来了。所以，结点的值未必是最后确定的最短路径值，只是当前松弛操作之后可以达到的最小的值，所以是一个`estimate`。到这里，不知道大家有没有发现一个现象：如果一个结点被加入了集合`S`，那么这个它的估计值就是最终确定的最短路径的值！这个问题是Dijkstra算法正确性的核心，是需要证明的，请参考下一节内容。

## 3、Dijkstra算法正确性的证明
&emsp;&emsp;Dikstra算法使用贪心策略，我们知道，使用贪心是需要证明的。上节最后已经提到了需要证明的内容，这里给形式化一下：
> 需要证明：结点`u`加入集合`S`时，有`dis[u] = shortest-path(s, u)`（a式）。

&emsp;&emsp;《算法导论》给出的证明是反证法，下面给出归纳法的证明思路，二者其实是一样的。
&emsp;&emsp;首先我们需要证明一个结论：
> `对于i∉S，dis[i] = min{dis[u] + map[u][i]，u∈S}`（b式）。

&emsp;&emsp;根据算法思路，每一个结点被加入集合`S`之后都需要进行松弛操作，根据松弛公式很容易得到这个结论。可能你会说，松弛公式的右边有个`dis[i]`而这个结论里面没有。这是因为`dis[i]`初始化的时候是无穷大，然后每次松弛都取较小值，那么最后就是取较小值里面的最小值。
&emsp;&emsp;下面给出归纳过程：
> * 起始情况下，`dis[s] = 0`满足a式。
> * 假设当前集合`S`内的结点都满足a式，接下来要加入的结点是`u`，`u∉S`。
> * 对于任意从`s`到`u`的路径`P`，我们将`P`分解为两段：`s...x—>y...u`，其中`s...x`的点都在`S`中，令这一半路径为`P1`；`y...u`目前还在`S`外，令这一段路径为`P2`。点`x`和`y`是分界。
>> * 根据归纳假设，`dis[x]`是确定了的最短路径值；
>> * 根据b式，`dis[y] <= dis[x] + map[x][y]`；
>> * 根据选择结点加入集合`S`的原则，`dis[y] >= dis[u]`；
>> * 所以可以得到：`L(P)=L(P1)+map[x][y]+L(P2)>=dis[x]+map[x][y]+L(P2)>=dis[y]+L(P2)>=dis[y]>=dis[u]`，L(P)表示路径长度。

> * 如上，可以证明，对于任意从`s`到`u`的路径`P`，`L(P)>=dis[u]`，所以`dis[u]`是最短路径值。

&emsp;&emsp;需要对证明的第三步做一些说明。
&emsp;&emsp;首先，对于连通图，路径`P`是一定会存在的；如果图是不连通的，存在点`m`，`shortest-path(s, m) = INF`，也就是不存在路径`P`，有两种处理方法。一种是直接将其加入集合`S`，此时`dis[m] = shortest-path(s, m) = INF`也是满足a式的；另一种是忽略这些结点，因为一开始初始化`dis[]`数组的时候，这些值就是`INF`，不需要处理也可以得到正确的结果，下一节的代码采取这种方式。从《算法导论》来看，加入集合`S`的点一定是连通的，即路径`P`一定存在。
&emsp;&emsp;其次，有可能`s = x`或者`y = u`，但是`x`和`y`是不同的结点。

## 4、Dijkstra算法的一种实现
&emsp;&emsp;下面的代码主要参考了红书，考虑到图的连通性等问题，我做了一点点修改。
``` cpp
int map[MAXN][MAXN];//邻接矩阵
int dis[MAXN];//最短路径数组
bool visit[MAXN];//是否加入集合S

void dijkstra(int start, int n){
    for(int i = 1; i <= n; i++)
        dis[i] = INF;
    memset(visit, 0, sizeof(visit));
    dis[start] = 0;
    for(int i = 1; i <= n; i++){
        int index = -1, mindis = INF;
        for(int j = 1; j <= n; j++){
            if(!visit[j] && dis[j] < mindis){
                mindis = dis[j];
                index = j;
            }
        }
        if(index == -1)break;//剩余结点都是不连通的，直接忽略，结束循环
        visit[index] = 1;
        for(int j = 1; j <= n; j++){
            if(!visit[j])
                dis[j] = min(dis[j], dis[index] + map[index][j]);
        }
    }
}
```
## 5、References
* [1]《算法导论》24.3 Dijkstra算法
* [2]《ACM国际大学生程序设计竞赛算法与实现》2.2.1 Dijkstra

