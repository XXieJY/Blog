## 1、最小生成树简介
&emsp;&emsp;对于什么是最小生成树，《算法导论》第23章一开始举了个例子，很形象，我就不多说了。下面解释一些基本的概念：
> * 对于图：最小生成树是基于**连通无向图**来说的，这个很好理解。
> * 对于树：树可以看做是特殊的图，无向无环并且连通。
> * 对于生成树：生成树是某个连通无向图的一部分，它连接了所有结点并且无环。形式化一点，假设连通无向图为`G(V, E)`（`V`是点集，`E`是边集），它的一棵生成树为`ST(V, E)`，则`ST.V = G.V`且`ST.E ⊆ G.E`。
> * 对于最小生成树：最小生成树就是生成树中**边权和**最小的树。

&emsp;&emsp;后续会介绍两个求最小生成树的方法`Kruskal`算法和`Prim`算法。二者都是基于贪心思想的，使用贪心是需要证明的，而对于当前问题，我们可以证明，某些贪心策略确实可以求得最小生成树。

## 2、Prim算法简介
&emsp;&emsp;`Prim`算法和`Dijkstra`算法很像，大家可以去看这篇[关于Dijkstra算法的博客](http://sunzequn.com/index.php/archives/156/)。`Prim`算法维护一个边的集合`A`，集合`A`中的边总是构成一棵树（所以也可以说是维护一棵树），然后不断加入新的边，直到覆盖了图的所有结点。算法的重点在于如何选择加入集合`A`的边，如果是求最小生成树，每次选择连接集合`A`和`A`之外结点（也就是`V-A`）的权最小的边，这是典型的贪心策略。
&emsp;&emsp;需要说明的是，边是有两个端点的，所以将边加入集合`A`，也就同时把边的两个端点也加入了集合，大家不要去纠结集合`A`的元素到底是边还是点，理解就好。实际上集合`A`的元素构成的是一棵树，下面的表述中会出现某边或者某点属于集合`A`，指的是这个边或者点属于这棵树。下面给出算法的过程：
> * 集合`A`初始化时只包含任意的一个结点，假设为结点`u`，即`A = {u}`，即这棵树只有一个结点，并且这个起始结点随意指定。
> * 选择一条边`(v1, v2)`，满足`v1 ∈ A`且`v2 ∈ V-A`且边的权值最小，将该边加入集合`A`（`v2`也加入了`A`）。这一步是算法最核心的部分，参考`Dijkstra`算法的思路，我们在具体实现的时候定义一个数组`dis[]`，`dis[i]`就是结点`i`到这棵树的直连的最短的距离，所谓直连就是直接连到这棵树的某个点。加入一个新的结点`v`后，需要去更新数组`dis[]`，公式为`dis[k] = min(dis[k], map[v][k])`，这些和`Dijkstra`算法太类似。
> * 重复上述步骤，直到集合`A`包含所有的结点，即最小生成树构造完成。

## 3、Prim算法的一种证明
### 3.1、证明前奏
&emsp;&emsp;`Prim`算法的证明和`Dijkstra`也是有相似的地方。《算法导论》在介绍最小生成树的时候，定义了**切割**、**横跨切割**和**轻量级边**等概念，由于比较陌生，大家可能读起来有点生涩。但是考虑到前文的铺垫和后续表达的方便简洁，我觉得还得使用这些概念。实际上，这些概念你已经了解了：
> * **切割**就是上文算法过程第2点中提到的集合`A`和`V-A`，是对结点集`V`的一个划分，将其划分为两个部分。
> * **横跨切割**类似于上文算法过程第2点中找的那条边`(v1, v2)`，只不过并不要求权值最小，只要满足`v1 ∈ A`且`v2 ∈ V-A`即可。
> * **轻量级边**就是横跨切割的边中，权值最小的边。上文算法过程第2点中找的那条边`(v1, v2)`就是一条轻量级边。

&emsp;&emsp;我们先来证明如下两个内容：
> * **证明1**：集合`A`中的边构成的是一棵树。
> * **证明2**：`Prim`算法第一次加入的边，一定属于某棵最小生成树。

&emsp;&emsp;**证明1**还是有必要的，因为如果`A`不构成树，那么就谈不上最后构成最小生成树了。集合`A`一开始只有一个结点（任意指定的初始结点），而后每次加入的，是一条轻量级边，`A`中新增的元素是1条边和这条边的1个端点。这样每次新增1边1点，加上原来已经存在的1点，只需要`n-1`次添加，就可以覆盖`n`个结点与`n-1`条边。很显然，`A`构成的图肯定是连通的，不会有孤立点（初始情况除外）。也很显然，`A`中不会有环，否则一定存在某次添加，加入集合`A`的边的两个结点都属于`A`，这是矛盾的。当然，从边数点数和连通性也能证明。所以，集合`A`中的边构成的是一棵树。后面只要证明这棵树是最小的即可。
&emsp;&emsp;对于**证明2**，令起始点为`s`，即`A = {s}`，第一次加入的边为`e1`，则`e1`是一条轻量级边，一个端点是`s`。使用反证法，如果最小生成树`T`不包含边`e1`，我们将`e1`加入`T`，那么一定会出现环。环中有结点`s`，`s`有两条边，一条是`e1`，令另一条是`e*`。很明显，`e*`也是横跨当前切割的一条边，并且`e* >= e1`。分类讨论，如果`e* > e1`，我们将边`e*`去掉，会得到一棵比最小生成树`T`更小的树，矛盾；如果`w(e*) = w(e1)`，我们将边`e*`去掉，会得到一棵新的最小生成树，与`e1`不属于最小生成树矛盾。故得证。

### 3.2、归纳法证明
&emsp;&emsp;我们依然使用归纳法来证明：
> * 初始条件：`Prim`算法第一次加入的边在最小生成树中（如上文证明2）。
> * 假设`Prim`算法前`n`步选择的边都在最小生成树中，我们来证明第`n+1`步选择的边也在最小生成树中：
> > * 使用反证法。令到`n`步之后，集合`A`中的树是`T*`，包含树`T*`的最小生成树是`T`，第`n+1`步选择加入的轻量级边是`e = (u, v)`， 结点`u`在`T*`中， `v`不在。
> > * 假设边`e`不在`T`中，那么令`p`为`T`中结点`u`到`v`的路径，则路径`p`中必存在一条横跨当前切割的边，令其为`e*`。后续证明就不说了，和证明2是一样的（其实只要一次证明就好了，我是为了构造一个规范的归纳法才拆开的）。
> * 综上所述，`Prim`算法最后构造出来的，是一棵最小生成树。

&emsp;&emsp;最后说一句，如果理解了证明思路，会发现，最小生成树不是唯一的，但是边权集合是唯一的。

## 4、Prim算法的一种实现
``` cpp
int map[MAXN][MAXN];//邻接矩阵
int dis[MAXN];//轻量级边
bool visit[MAXN];//是否加入集合A
int ans;

void prim(int n){
    ans = 0;
    for(int i = 1; i <= n; i++)
        dis[i] = INF;
    memset(visit, 0, sizeof(visit));
    dis[1] = 0;
    for(int i = 1; i <= n; i++){
        int index = -1, mindis = INF;
        for(int j = 1; j <= n; j++){
            if(!visit[j] && dis[j] < mindis){
                mindis = dis[j];
                index = j;
            }
        }
        visit[index] = 1;
        ans += dis[index];
        for(int j = 1; j <= n; j++){
            if(!visit[j])
                dis[j] = min(dis[j], map[index][j]);
        }
    }
}
```
&emsp;&emsp;代码基本和`Dijkstra`算法一样，时间复杂度为`O(n^2)`，也是可以继续优化的，和`Dijkstra`算法一样。

## 5、References
* [1]《算法导论》23 最小生成树
